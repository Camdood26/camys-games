<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Camy Pong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root { --max-w: 800px; --aspect: 0.625; } /* 800x500 -> 500/800 = 0.625 */
    html, body { height:100%; margin:0; }
    body {
      display:flex; justify-content:center; align-items:center;
      background:#ffffff; font-family:Arial, Helvetica, sans-serif;
      padding:12px; box-sizing:border-box;
    }
    #wrap {
      position:relative;
      width: min(95vw, var(--max-w));
      /* keep aspect ratio; actual canvas resolution is handled in JS */
      height: calc(min(95vw, var(--max-w)) * var(--aspect));
      max-height: calc(100vh - 140px);
      /* if very tall screen, grow to height */
    }
    @media (max-height: 560px) {
      #wrap { width: min(98vw, var(--max-w)); height: calc(min(98vw, var(--max-w)) * var(--aspect)); }
    }
    canvas {
      display:block; width:100%; height:100%;
      background:transparent; border-radius:12px; box-shadow:0 4px 14px rgba(0,0,0,.2);
      touch-action:none; /* prevent scrolling while dragging */
    }

    /* Top overlays */
    .title {
      position:absolute; left:0; right:0; top:-38px;
      text-align:center; font-weight:900; font-size:clamp(1.1rem, 3.2vw, 1.8rem);
      letter-spacing:.5px; user-select:none; text-shadow:0 2px 6px rgba(0,0,0,.2);
    }
    .hud {
      position:absolute; left:8px; top:8px; font-weight:bold; user-select:none;
      background:rgba(255,255,255,.6); padding:6px 10px; border-radius:8px;
      font-size:clamp(.8rem, 2.2vw, 1rem);
    }
    .diff {
      position:absolute; right:8px; top:8px; user-select:none;
      background:rgba(255,255,255,.6); padding:6px 10px; border-radius:8px;
      display:flex; align-items:center; gap:10px; font-weight:bold;
      font-size:clamp(.8rem, 2.2vw, 1rem);
    }
    .bar { width:min(38vw, 180px); height:12px; border-radius:8px; background:rgba(0,0,0,.15); overflow:hidden; }
    .fill { height:100%; width:0%; background:#4CAF50; transition:width .12s linear, background-color .3s linear; }

    .centerText {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      text-align:center; padding:20px; font-size:clamp(1rem, 3vw, 1.1rem); font-weight:bold; user-select:none;
      background: none;
      pointer-events:auto;
    }
    .btn {
      display:inline-block; margin-top:10px; padding:10px 14px; border-radius:10px;
      background:#4CAF50; color:#fff; text-decoration:none;
      font-size:clamp(.9rem, 2.6vw, 1rem);
    }

    /* Big tap to start button for mobile */
    .startBtn {
      margin-top:14px; padding:12px 18px; border-radius:12px; background:#3b82f6; color:#fff; display:inline-block;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div class="title">Camy Pong</div>
    <canvas id="game"></canvas>

    <div class="hud" id="hud">Score: 0 | High: 0</div>

    <div class="diff" id="diffBox">
      <span>Difficulty</span>
      <div class="bar"><div class="fill" id="diffFill"></div></div>
      <span id="diffPct">0%</span>
    </div>

    <div class="centerText" id="overlay">
      <div>
        <div>Press <span style="padding:0 6px; border:1px solid #333; border-radius:6px; margin:0 4px;">S</span> or tap <b>Start</b> to play.</div>
        <div style="opacity:.8; margin-top:4px;">Use â—€ â–¶, mouse, or drag on the screen to move the paddle.</div>
        <div class="startBtn" id="tapStart">â–¶ Start</div>
      </div>
    </div>
  </div>

  <script>
    const wrap = document.getElementById('wrap');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');
    const overlay = document.getElementById('overlay');
    const tapStart = document.getElementById('tapStart');
    const diffFill = document.getElementById('diffFill');
    const diffPct = document.getElementById('diffPct');

    // ----- HiDPI & Responsive Canvas -----
    function sizeCanvas() {
      const cssW = wrap.clientWidth;
      const cssH = wrap.clientHeight;
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
      // Normalize drawing coordinates to CSS pixels
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      bounds.w = cssW; bounds.h = cssH;
      // Keep paddle inside bounds if resized
      paddle.x = Math.max(0, Math.min(bounds.w - paddle.w, paddle.x));
      paddle.y = bounds.h - 30; // stick to bottom margin
    }
    const bounds = { w: 800, h: 500 }; // logical size follows CSS after sizeCanvas()

    // ---------- SOUND (Web Audio, no external files) ----------
    let audioCtx = null;
    function getCtx() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); return audioCtx; }
    function tone({freq=440, type='sine', dur=0.12, gain=0.15, startFreq=null}) {
      const ac = getCtx();
      const t0 = ac.currentTime;
      const osc = ac.createOscillator();
      const g = ac.createGain();
      osc.type = type;
      osc.frequency.value = startFreq ?? freq;
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(gain, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      if (startFreq && startFreq !== freq) {
        osc.frequency.setValueAtTime(startFreq, t0);
        osc.frequency.exponentialRampToValueAtTime(freq, t0 + dur);
      }
      osc.connect(g).connect(ac.destination);
      osc.start(t0);
      osc.stop(t0 + dur);
    }
    function playBoing(){ tone({type:'sine', startFreq:280, freq:520, dur:0.12, gain:0.18}); }
    function playWallBoing(){ tone({type:'sine', startFreq:220, freq:380, dur:0.09, gain:0.14}); }
    function playBuzz(){
      const ac = getCtx(), t0 = ac.currentTime;
      const osc = ac.createOscillator(), g = ac.createGain();
      osc.type = 'square'; osc.frequency.setValueAtTime(240, t0);
      osc.frequency.exponentialRampToValueAtTime(80, t0 + 0.35);
      g.gain.setValueAtTime(0, t0); g.gain.linearRampToValueAtTime(0.2, t0 + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.4);
      osc.connect(g).connect(ac.destination); osc.start(t0); osc.stop(t0 + 0.42);
    }
    async function playFanfare(){
      const notes=[261.63,329.63,392.00,523.25];
      for (let n of notes){ tone({type:'triangle', freq:n, dur:0.12, gain:0.18}); await new Promise(r=>setTimeout(r,120)); }
      tone({type:'triangle', freq:659.25, dur:0.18, gain:0.2});
    }

    // ---------- GAME STATE ----------
    const HS_KEY = 'camy_pong_highscore';
    let highScore = Number(sessionStorage.getItem(HS_KEY) || 0);

    let running = false, gameOver = false;

    const paddle = { w:120, h:16, x:0, y:0, speed:7, moveLeft:false, moveRight:false };
    const ball = { x:0, y:0, r:9, vx:3, vy:-3 };

    let score = 0, hitsSinceBoost = 0, fanfarePlayedThisScore = false;

    // ---------- INPUT (Keyboard + Mouse + Touch) ----------
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') paddle.moveLeft = true;
      if (e.key === 'ArrowRight') paddle.moveRight = true;
      if ((e.key === 's' || e.key === 'S') && (!running || gameOver)) startGame();
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') paddle.moveLeft = false;
      if (e.key === 'ArrowRight') paddle.moveRight = false;
    });

    // Mouse move
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      paddle.x = Math.min(bounds.w - paddle.w, Math.max(0, mx - paddle.w/2));
    });

    // Touch: drag anywhere on the canvas to position the paddle
    function touchToX(touch) {
      const rect = canvas.getBoundingClientRect();
      return touch.clientX - rect.left;
    }
    canvas.addEventListener('touchstart', (e) => {
      getCtx(); // unlock audio on first touch
      const x = touchToX(e.changedTouches[0]);
      paddle.x = Math.min(bounds.w - paddle.w, Math.max(0, x - paddle.w/2));
      // Tap to start
      if (!running || gameOver) startGame();
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      const x = touchToX(e.changedTouches[0]);
      paddle.x = Math.min(bounds.w - paddle.w, Math.max(0, x - paddle.w/2));
      e.preventDefault();
    }, { passive: false });

    // Tap â€œStartâ€ button
    tapStart.addEventListener('click', () => { getCtx(); if (!running || gameOver) startGame(); });

    // ---------- GAME FLOW ----------
    function resetBall() {
      const speed = 3;
      const angle = (Math.random()*0.6 + 0.2) * (Math.random() < 0.5 ? 1 : -1);
      ball.x = bounds.w / 2;
      ball.y = bounds.h / 2;
      ball.vx = speed * angle * 2;
      ball.vy = -speed * 2;
    }

    function startGame() {
      running = true; gameOver = false;
      score = 0; hitsSinceBoost = 0; fanfarePlayedThisScore = false;
      // place paddle near bottom based on current bounds
      paddle.y = bounds.h - 30; paddle.w = Math.min(140, Math.max(90, bounds.w * 0.15));
      paddle.x = (bounds.w - paddle.w) / 2;
      resetBall();
      overlay.style.display = 'none';
      loop();
    }

    function loop() {
      if (!running) return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      // Paddle keys
      if (paddle.moveLeft)  paddle.x -= paddle.speed;
      if (paddle.moveRight) paddle.x += paddle.speed;
      paddle.x = Math.max(0, Math.min(bounds.w - paddle.w, paddle.x));

      // Ball movement
      ball.x += ball.vx; ball.y += ball.vy;

      // Wall bounces
      if (ball.x - ball.r <= 0 && ball.vx < 0) { ball.x = ball.r; ball.vx *= -1; playWallBoing(); }
      if (ball.x + ball.r >= bounds.w && ball.vx > 0) { ball.x = bounds.w - ball.r; ball.vx *= -1; playWallBoing(); }
      if (ball.y - ball.r <= 0 && ball.vy < 0) { ball.y = ball.r; ball.vy *= -1; playWallBoing(); }

      // Paddle bounce
      if (
        ball.y + ball.r >= paddle.y &&
        ball.y + ball.r <= paddle.y + paddle.h &&
        ball.x >= paddle.x &&
        ball.x <= paddle.x + paddle.w &&
        ball.vy > 0
      ) {
        ball.y = paddle.y - ball.r;
        ball.vy *= -1;

        const hitPos = ((ball.x - paddle.x) / paddle.w) - 0.5; // -0.5..0.5
        ball.vx += hitPos * 2;

        score++; hitsSinceBoost++; playBoing();

        // Every 5 hits -> 5% faster
        if (hitsSinceBoost >= 5) {
          hitsSinceBoost = 0;
          ball.vx *= 1.05; ball.vy *= 1.05;
        }
      }

      // Lose
      if (ball.y - ball.r > bounds.h) endGame();

      // Background tint & HUD
      setBackgroundTint(score);
      hud.textContent = `Score: ${score} | High: ${highScore}`;

      // Difficulty bar: score/5, cap 100%, colour change
      const pct = Math.min(100, Math.floor(score / 5));
      diffFill.style.width = pct + '%';
      if (pct <= 30) { diffFill.style.background = '#4CAF50'; }
      else if (pct <= 70) { diffFill.style.background = '#f59e0b'; }
      else { diffFill.style.background = '#ef4444'; }
      diffPct.textContent = pct + '%';

      // Fanfare on beating session high
      if (!fanfarePlayedThisScore && score > highScore) {
        fanfarePlayedThisScore = true;
        playFanfare();
      }
    }

    function setBackgroundTint(score) {
      const steps = Math.floor(score / 5);
      const factor = Math.max(0, 1 - 0.01 * steps);
      const gb = Math.round(255 * factor);
      document.body.style.backgroundColor = `rgb(255, ${gb}, ${gb})`;
    }

    function draw() {
      // Contrast color for paddle/ball
      const bodyBg = window.getComputedStyle(document.body).backgroundColor;
      const gb = Number(bodyBg.match(/\d+/g)[1]); // green channel
      const useDark = gb > 128;
      const fg = useDark ? '#000' : '#fff';

      ctx.clearRect(0, 0, bounds.w, bounds.h);

      // Paddle
      ctx.fillStyle = fg;
      roundRect(ctx, paddle.x, paddle.y, paddle.w, paddle.h, 8);
      ctx.fill();

      // Ball
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.fillStyle = fg;
      ctx.fill();
    }

    function endGame() {
      running = false; gameOver = true;
      playBuzz();

      if (score > highScore) {
        highScore = score;
        sessionStorage.setItem(HS_KEY, String(highScore));
      }

      overlay.innerHTML = `
        <div>
          ðŸŽ‰ <div style="font-size:1.3rem; margin-top:6px;">Congratulations!</div>
          <div style="margin-top:8px;">Final score: <b>${score}</b></div>
          <div>High score (this session): <b>${highScore}</b></div>
          <div style="margin-top:10px;">Tap <b>Start</b> or press <span style="padding:0 6px; border:1px solid #333; border-radius:6px; margin:0 4px;">S</span> to play again.</div>
          <div class="startBtn" id="tapStart2" style="margin-top:12px;">â–¶ Start</div>
          <div style="margin-top:12px;"><a class="btn" href="index.html">â¬… Back to The Camy Games</a></div>
        </div>
      `;
      overlay.style.display = 'flex';
      // re-bind the new Start button
      document.getElementById('tapStart2').onclick = () => { if (!running || gameOver) startGame(); };
    }

    // Utility: rounded rect
    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    // Init & resize
    window.addEventListener('resize', sizeCanvas);
    sizeCanvas(); // set bounds to CSS size and scale canvas
    // Place default paddle position before first start
    paddle.y = bounds.h - 30; paddle.w = Math.min(140, Math.max(90, bounds.w * 0.15));
    paddle.x = (bounds.w - paddle.w) / 2;

    // Initial HUD
    hud.textContent = `Score: 0 | High: ${highScore}`;
  </script>
</body>
</html>
